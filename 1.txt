2) 1. FOOD RELATION 
Facts 
food(burger). 
food(sandwich). 
food(pizza). 
lunch(sandwich). 
dinner(pizza). 
Rules 
meal(X) :- food(X). 
Queries / Goals 
?- food(pizza). 
?- meal(X), lunch(X). 
?- dinner(sandwich). 
output
?- ['1.PL']. 
true 
?- food(pizza). 
true 
?- meal(X), lunch(X). 
X= sandwich 
?- dinner(sandwich). 
False



2. STUDENT – TEACHER RELATION 
Facts 
studies(charlie, csc135). 
studies(olivia, csc135). 
studies(jack, csc131). 
studies(arthur, csc134). 
teaches(kirke, csc135). 
teaches(collins, csc131). 
teaches(collins, csc171). 
teaches(juniper, csc134). 
Rules 
professor(X, Y) :- 
teaches(X, C), studies(Y, C) 
Queries / Goals 
?- studies(charlie, What). 
?- professor(kirke, Students). 
output
?- [‘2.pl’]. 
true 
?- studies(Charlie,What). 
What = cse135. 
?- professor(kirke,students). 
false 
?- professor(kirke,Students). 
Students = Charlie; 
Students = Olivia.



3: PROGRAM TO DEMONSTRATE FAMILY RELATIONSHIP 
predicates 
parent(symbol,symbol) 
child(symbol,symbol) 
mother(symbol,symbol) 
brother(symbol,symbol) 
sister(symbol,symbol) 
grandparent(symbol,symbol) 
male(symbol) 
female(symbol) 
clauses 
parent(a,b). 
sister(a,c). 
male(a). 
female(b). 
child(X,Y):-parent(Y,X). 
mother(X,Y):-female(X),parent(X,Y). 
grandparent(X,Y):-parent(X,Z),parent(Z,Y). 
brother(X,Y):-male(X),parent(V,X),parent(V,Y). 
output
Goal: chilf(X,h) 
No solution 
Goal: female(b) 
Yes 
Goal: male(a) 
Yes



4.PROGRAM TO CATEGORISE ANIMAL CHARACTERISTICS. 
predicates 
small(symbol) 
large(symbol) 
color(symbol,symbol) 
clauses 
small(rat). 
small(cat). 
large(lion). 
color(dog,black). 
color(rabbit,white). 
color(X,dark):- 
color(X,black);color(X,brown). 
output
Goal: small(X) 
X=rat 
X=cat 
2 solutions



5: PROGRAM TO SHOW HOW INTEGER VARIABLE IS USED IN PROLOG PROGRAM 
predicates 
go 
clauses 
go:-X=10, 
write(X), 
nl,X=20, 
write(X),nl.
OUTPUT
Goal: go 
10 
No



6. ARITHMETIC OPERATIONS 
?- X is 3+2. // expression on right side of 'is' 
X = 5. 
?- 3+2 is X. // expression on left side of 'is' 
ERROR: is/2: Arguments are not sufficiently instantiated 
?- X = 3+2. // just instantiate variable X to value 3+2 
X = 3+2. 
?- 3+2 = X. 
X = 3+2. 
?- X is +(3,2). 
X = 5. 
?- 5 is 3+2. 
true. 
?- 3+2 is 5. 
false. 
?- X is 3*2. 
X = 6. 
?- X is 3-2. 
X = 1. 
?- X is -(2,3). 
X = -1. 
?- X is 5-3-1. 
X = 1. 
?- X is -(5,3,1). 
ERROR: is/2: Arithmetic: `(-)/3' is not a function 
?- X is -(-(5,3),1). 
X = 1. 
?- X is 5-3-1. 
X = 1 
?- X is 3/5. 
X = 0.6. 
?- X is 3 mod 5. 
X = 3. 
?- X is 5 mod 3. 
X = 2. 
?- X is 5^3. 
X = 125. 
?- X is (5^3)^2. 
X = 15625. 
?- X = (5^3)^2. 
X = (5^3)^2. 
?- 25 is 5^2. 
true. 
?- Y is 3+2*4-1. 
Y = 10. 
?- Y is (3+2)*(4)-(1). 
Y = 19. 
?- Y is -(*(+(3,2),4),1). 
Y = 19. 
?- X is 3*2, Y is X*2. 
X = 6, 
Y = 12. 
OUTPUT
---------------------------------------------------------------------------------



7. PROGRAM TO ADD TWO NUMBERS. 
predicates 
add 
clauses 
add :- 
write('Input first number: '), nl, 
read(X), 
write('Input second number: '), nl, 
read(Y), 
Z is X + Y, 
write('Output = '), write(Z), nl. 
OUTPUT
Goal: add 
Input first number 4 
Input second number 7 
Output=11 yes



8: PROGRAM TO READ ADDRESS OF A PERSON USING COMPOUND VARIABLE . 
domains 
person=address(name,street,city,state,zip) 
name,street,city,state,zip=String 
predicates 
readaddress(person) 
go 
clauses 
% Entry point 
go :- 
readaddress(Address), 
nl, write(Address), nl, nl, 
write("Accept (y/n)? "), read_line_to_string(user_input, Reply), 
(Reply = "y" -> ! ; nl, write("Please re-enter"), nl, go). 
% Address reader 
readaddress(address(Name, Street, City, State, Zip)) :- 
write("Name: "), read_line_to_string(user_input, Name), 
write("Street: "), read_line_to_string(user_input, Street), 
write("City: "), read_line_to_string(user_input, City), 
write("State: "), read_line_to_string(user_input, State), 
write("Zip: "), read_line_to_string(user_input, Zip). 
OUTPUT
Goal: go 
Name: Ram 
Street: South Street 
City: Trichy 
State:Tamilnadu 
Zip: 621000 
Address(“Ram”,”South Street”,”Trichy”,”Tamilnadu”,”621000”). 
Accept (y/n)? 
y ----/true



9: PROGRAM OF FUN TO SHOW CONCEPT OF CUT OPERATOR . 
predicates 
fun(integer,integer) 
clauses 
% Predicate declaration: fun(Y, X) 
% Clause 1: If Y < 3, then X = 1 
fun(Y, 1) :- 
Y < 3, !. 
% Clause 2: If 3 < Y =< 10, then X = 2 
fun(Y, 2) :- 
Y > 3, 
Y =< 10, !. 
% Clause 3: If Y > 10, then X = 3 
fun(Y, 3) :- 
Y > 10, !.
OUTPUT
Goal:fun(2,X) 
X=1 
Goal: fun(4,1) 
No. 
Goal: fun(2,3) 
Yes



10.TOWERS OF HANOI 
move(1,X,Y,_) :- 
write('Move top disk from '), 
write(X), 
write(' to '), 
write(Y), 
nl. 
move(N,X,Y,Z) :- 
N>1, 
M is N-1, 
move(M,X,Z,Y), 
move(1,X,Y,_), 
move(M,Z,Y,X). 
Query/Goal 
?- move(3,left,right,center).
OUTPUT
Move top disk from left to right 
Move top disk from left to center 
Move top disk from right to center 
Move top disk from left to right 
Move top disk from center to left 
Move top disk from center to right 
Move top disk from left to ri





3) 

1 : PROGRAMTOCOUNTNUMBEROFELEMENTSINALIST.
 domains
 x=integer
 list=integer*
 predicates
 count(list,x)
 clauses
 count([],0).
 count([_|T],N):
count(T,N1),
 Nis N1+1.
OUTPUT
Goal: count([],X)
 X=0
 1 solution
 Goal: count([1,2,3,4,5,6,7,8,9,0,[]],X)
 X=11
 1 solution



2 : PROGRAMTOREVERSETHELIST .
 domains
 x=integer
 list=integer*
 predicates
 append(x,list,list)
 rev(list,list)
 clauses
 %append/3: Appends two lists
 append([], L, L).
 append([H|T], L, [H|R]) :
append(T, L, R).
 %rev/2: Reverses a list
 rev([], []).
 rev([H|T], R) :
rev(T, RT),
 append(RT, [H], R).
OUTPUT
Goal: append([2], [3,4,5], X).
 X =[2, 3, 4, 5]
 1 solution
 Goal: rev([2,3,4], X).
 X =[4, 3, 2]
 1 solution



3: PROGRAM TOAPPENDANINTEGER INTOTHE LIST .
 domains
 x=integer
 list=integer*
 predicates
 append(x,list,list)
 clauses
 %append/3: Appends two lists
 append([], L, L).
 append([H|T], L, [H|R]) :
append(T, L, R).
 %rev/2: Reverses a list
 rev([], []).
 rev([H|T], R) :
rev(T, RT),
 append(RT, [H], R).
OUTPUT
Goal: append([1,[2,3,4,5],X)
 X=[2,3,4,5,1]
 1 solution




4: PROGRAM TOREPLACEANINTEGER FROMTHE LIST.
 domains
 list=integer*
 predicates
 replace(integer,integer,list,list)
 clauses
 %Base case: if the head matches X, replace it with Y and stop
 replace(X, Y, [X | T], [Y | T]).
 %Recursive case: keep the head, and replace in the tail
 replace(X, Y, [H | T], [H | T1]) :
replace(X, Y, T, T1).
OUTPUT
Goal: replace(3, x, [1, 2, 3, 4, 3], R).
R =[1, 2, x, 4, 3] 
R =[1, 2, 3, 4, x] 
false 
1 solution



5: PROGRAM TODELETEANINTEGERFROM THELIST .
 domains
 list=integer*
 predicates
 del(integer,list,list)
 clauses
 del(X,[X|T],T).
 del(X,[H|T],[H|T1]):
del(X,T,T1).
OUTPUT
Goal:del(3,[2,3,4],X)
 X =[2, 4]
 false
 1 solution



6: PROGRAM TOSHOWCONCEPTOFLIST.
 domains
 name=symbol*
 predicates
 itnames(name)
 clauses
 itnames([ram,kapil,shweta]).
 itnames([ram,shweta,kapil]).
OUTPUT
Goal: itnames(Y)
 Y=[“ram,”kapil”,”shweta”]
 Y=[“ram”,”shweta”,”kapil”]
 2 solutions
 Goal: itnames([ram|T])
 T=[“kapil”,”shweta”]
 T=[“shweta”,”kapil”]
 2 solutions



4) PROGRAM 8 – QUEENS PROBLEM
DOMAINS 
cell = c(integer, integer) 
list = cell* 
int_list = integer* 
PREDICATES 
solution(list) 
member(integer, int_list) 
nonattack(cell, list) 
CLAUSES 
% Base case: an empty board has a valid solution 
solution([]). 
% Recursive case: place a queen at column Y in row X 
solution([c(X, Y) | Others]) :- 
solution(Others), 
member(Y, [1,2,3,4,5,6,7,8]), % 8-queens (columns 1 to 8) 
nonattack(c(X, Y), Others). 
% Base case: no queen to compare with 
nonattack(_, []). 
% Ensure current queen does not attack any previously placed queen 
nonattack(c(X, Y), [c(X1, Y1) | Others]) :- 
Y =\= Y1, % not in same column 
abs(Y1 - Y) =\= abs(X1 - X), % not in same major diagonal 
abs(Y1 - Y) =\= abs(X - X1), % not in same minor diagonal 
nonattack(c(X, Y), Others). 
% Standard member predicate 
member(X, [X | _]). 
member(X, [_ | Z]) :- 
member(X, Z). 
GOAL 
solution([c(1,A),c(2,B),c(3,C),c(4,D),c(5,E),c(6,F),c(7,G),c(8,H)]).
OUTPUT
--------------------------------------------------------------------------------------------------



5) PROGRAM 
domains 
X=symbol 
Y=symbol* 
predicates 
child(X,X) 
childnode(X,X,Y) 
path(X,X,Y) 
clauses 
child(a,b). /*b is child of a*/ 
child(a,c). /*c is child of a*/ 
child(a,d). /*d is child of a*/ 
child(b,e). /*b is child of b*/ 
child(b,f). /*f is child of b*/ 
child(c,g). /*g is child of c*/ 
path(A,G,[A|Z]):- /*to find the path from root to leaf*/ 
childnode(A,G,Z). 
childnode(A,G,[G]):- /*to determine whether a node is child of other*/ 
child(A,G). childnode(A,G,[X|L]):- child(A,X), childnode(X,G,L).
OUTPUT
Goal: path(a,b,L). 
L=[“a”,”b”] 
false 
1 Solution





6) PROGRAM  
predicates  
nondeterm road(town,town,distance)  
nondeterm route(town,town,distance  
route(Town1,Town2,Distance)  
road(Town1,Town2,Distance).  
route(Town1,Town2,Distance)  
road(Town1,X,Dist1),  
route(X,Town2,Dist2),  
Distance=Dist1+Dist2,  
domains  
town = symbol  
distance = integer  
predicates  
nondeterm road(town,town,distance)  
nondeterm route(town,town,distance)  
clauses  
% Facts  
road(tampa, houston, 200).  
road(gordon, tampa, 300).  
road(houston, gordon, 100).  
road(houston, kansas_city, 120).  
road(gordon, kansas_city, 130).  
% Rules  
route(Town1, Town2, Distance) :-  
road(Town1, Town2, Distance).  
route(Town1, Town2, Distance) :-  
road(Town1, X, Dist1),  
route(X, Town2, Dist2),  
Distance is Dist1 + Dist2.  
% Run query in REPL:  
% ?- route(tampa, kansas_city, X).
OUTPUT
route(tampa, kansas_city, X).   
X=320     
Solution






7) PROGRAM  
CLAUSES  
% 8-Puzzle Solver using BFS in SWI-Prolog  
% ---------- Move Definitions ----------  
move(State, NewState) :- move_left(State, NewState).  
move(State, NewState) :- move_right(State, NewState).  
move(State, NewState) :- move_up(State, NewState).  
move(State, NewState) :- move_down(State, NewState).  
move_left([0,A,B|T],[A,0,B|T]).  
move_left([A,0,B|T],[A,B,0|T]).  
move_left([A,B,C|T],[A,B,C|T1]) :- move_left(T, T1).  
move_right([A,B,0|T],[A,0,B|T]).  
move_right([A,0,B|T],[0,A,B|T]).  
move_right([A,B,C|T],[A,B,C|T1]) :- move_right(T, T1).  
move_up([0,A,B,C|T],[C,A,B,0|T]).  
move_up([H|T],[H|T1]) :- move_up(T, T1).  
move_down([A,B,C,0|T],[0,B,C,A|T]).  
move_down([H|T],[H|T1]) :- move_down(T, T1).  
% ---------- Goal Check ----------  
goal([1,2,3,4,5,6,7,8,0]).  
% ---------- Puzzle BFS Solver ----------  
puzzle(State) :-  
bfs([[State]], [], SolutionPath),  
reverse(SolutionPath, OrderedPath),  
write_solution(OrderedPath, 0).  
bfs([[State|Path]|_], _, [State|Path]) :-  
goal(State), !.  
bfs([[State|Path]|Rest], Visited, Solution) :-  
findall([NextState,State|Path],  
(move(State, NextState),  
\+ member(NextState, [State|Path]),  
\+ member(NextState, Visited)),  
NewPaths),  
append(Rest, NewPaths, Queue),  
bfs(Queue, [State|Visited], Solution).  
% ---------- Output ----------  
write_solution([], _).  
write_solution([State|Rest], N) :-  
format("Step ~w:\n", [N]),  
print_state(State),  
nl,  
N1 is N + 1,  
write_solution(Rest, N1).  
print_state([]).  
print_state([A,B,C|T]) :-  
format("~w ~w ~w\n", [A,B,C]),  
print_state(T).  
% ---------- Entry Point ----------  
start :-  
InitialState = [1,2,3,4,5,6,0,7,8], % You can change this to any solvable state  
puzzle(InitialState).
OUTPUT
Goal: start.  
Step 0:  
1 2 3  
4 5 6  
0 7 8  
Step 1:  
1 2 3  
4 5 6  
7 0 8  
Step 2:  
1 2 3  
4 5 6  
7 8 0 
1true






8) PROGRAM  
% Monkey and Banana Problem in SWI-Prolog  
% Entry point  
go :-  
take("monkey", "stick"),  
move("monkey", "chair"),  
get_on("monkey", "chair"),  
hit("monkey", "stick", "banana"),  
writeln("The monkey has hit the banana!"), !.  
go :-  
writeln("The monkey couldn't reach the banana.").  
% Interaction predicates  
take(Animal, Object) :-  
format("Does the ~w take the ~w? (y/n): ", [Animal, Object]),  
read(Reply),  
Reply = y.  
move(Animal, Object) :-  
format("Does the ~w move the ~w? (y/n): ", [Animal, Object]),  
read(Reply),  
Reply = y.  
get_on(Animal, Object) :-  
format("Does the ~w get on the ~w? (y/n): ", [Animal, Object]),  
read(Reply),  
Reply = y.  
hit(Animal, Tool, Target) :-  
format("Does the ~w hit the ~w with the ~w? (y/n): ", [Animal, Target, Tool]),  
read(Reply),  
Reply = y.
OUTPUT
---------------------------------------------------------------------------------------------------




9) 
% Water Jug Problem: Get exactly 2 gallons in the 4-gallon jug  
% Jugs: 4-gallon (X), 3-gallon (Y)  
:- dynamic rstate/2.  
% Start the process from (0,0)  
start :-  
retractall(rstate(_, _)),      
% clear previous state  
assert(rstate(0, 0)),           
% initial state  
writeln("Starting from (0, 0)"),  
state(0, 0).  
% Goal state  
state(2, 0) :-  
\+ rstate(2, 0),  
assert(rstate(2, 0)),  
writeln("\nGoal reached: (2, 0)"), !.  
% Rule 1: Fill 4-gallon jug  
state(X, Y) :-  
X < 4,  
\+ rstate(4, Y),  
assert(rstate(4, Y)),  
format('Rule 1 => (4, ~w)~n', [Y]),  
state(4, Y).  
% Rule 2: Fill 3-gallon jug  
state(X, Y) :-  
Y < 3,  
\+ rstate(X, 3),  
assert(rstate(X, 3)),  
format('Rule 2 => (~w, 3)~n', [X]),  
state(X, 3).  
% Rule 3: Empty 4-gallon jug  
state(X, Y) :-  
X > 0,  
\+ rstate(0, Y),  
assert(rstate(0, Y)),  
format('Rule 3 => (0, ~w)~n', [Y]),  
state(0, Y).  
% Rule 4: Empty 3-gallon jug  
state(X, Y) :-  
Y > 0,  
\+ rstate(X, 0),  
assert(rstate(X, 0)),  
format('Rule 4 => (~w, 0)~n', [X]),  
state(X, 0).  
% Rule 5: Pour from 3L to 4L until 4L is full  
state(X, Y) :-  
X + Y >= 4,  
Y > 0,  
Z is Y - (4 - X),  
\+ rstate(4, Z),  
assert(rstate(4, Z)),  
format('Rule 5 => (4, ~w)~n', [Z]),  
state(4, Z).  
% Rule 6: Pour from 4L to 3L until 3L is full  
state(X, Y) :-  
X + Y >= 3,  
X > 0,  
Z is X - (3 - Y),  
\+ rstate(Z, 3),  
assert(rstate(Z, 3)),  
format('Rule 6 => (~w, 3)~n', [Z]),  
state(Z, 3).  
% Rule 7: Pour from 3L to 4L until 3L is empty  
state(X, Y) :-  
X + Y =< 4,  
Y > 0,  
Z is X + Y,  
\+ rstate(Z, 0),  
assert(rstate(Z, 0)),  
format('Rule 7 => (~w, 0)~n', [Z]),  
state(Z, 0).  
% Rule 8: Pour from 4L to 3L until 4L is empty  
state(X, Y) :-  
X + Y =< 3,  
X > 0,  
Z is X + Y,  
\+ rstate(0, Z),  
assert(rstate(0, Z)),  
format('Rule 8 => (0, ~w)~n', [Z]),  
state(0, Z).  
% Base case to prevent infinite recursion  
state(_, _) :- !.
OUTPUT
Goal: start.  
Rule 1 => (4, 0)  
Rule 2 => (4, 3)  
Rule 3 => (0, 3)  
Rule 7 => (3, 0)  
Rule 2 => (3, 3)  
Rule 5 => (4, 2)  
Rule 3 => (0, 2)  
Rule 7 => (2, 0)  
Rule 2 => (2, 3)  
Rule 5 => (4, 1)  
Rule 3 => (0, 1)  
Rule 7 => (1, 0)  
Rule 2 => (1, 3)  
1true



